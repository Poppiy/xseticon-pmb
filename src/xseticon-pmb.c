/*
 * Copyright (C) 2012, Paul Evans <leonerd@leonerd.org.uk>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 */

#include <stdio.h>
#include <glib.h>
#include <X11/Xlib.h>
#include <X11/Xatom.h>
#include <gd.h>

// usage.h is generated by usage.gen.sed from README.md
#include "auto-generated/usage.h"

typedef unsigned long int CARD32;
/* ^-- We can't use the one defined in Xmd.h because that's an
  "unsigned int", which comes out as a 32bit type always.
  We need this to be 64bit on 64bit machines.

  2022-05-09: Not sure what Paul meant with that comment.
    Maybe about bit width of the system where it was compiled?
    The binary produced by compiling on 32-bit Ubuntu trusty
    works perfectly on 64-bit Ubuntu focal.
*/

typedef gdImagePtr (*image_reader_fun_ptr)(FILE*);
typedef unsigned char uchar;

gboolean verbose = FALSE;


void usage(int exitcode) {
  printf(README_USAGE);
  exit(exitcode);
}


// FROM programs/xlsfonts/dsimple.c
    // (This part is intentionally omitted in the PmB version.)
// END FROM


void failed(gchar* msg, ...) {
  va_list details;
  va_start(details, msg);
  fprintf(stderr, "E: Failed to %s", msg);
  vfprintf(stderr, " %s", details);
  fprintf(stderr, "\n");
  va_end(details);
  exit(1);
}


image_reader_fun_ptr decide_image_reader(gchar* type, gchar* path) {
  if (!strcmp(type, "GUESS")) {
    int fext_offset = strlen(path) - 4;
    if (fext_offset < 0) { failed("find filename extension in path", path); }
    gchar* fext = path + fext_offset;
    if ((*fext) != '.') { failed("find filename extension in path", path); }
    fext += 1;
    return decide_image_reader(fext, path);
  }
  if (!strcmp(type, "png")) { return &gdImageCreateFromPng; }
  failed("load image: Unsupported image type:", type);
  return NULL; // Won't ever be reached. Just to mute the warning.
}


void dump_hex(const uchar* bytes, const uchar offset, const uchar length) {
  uchar end = offset + length;
  uchar pos;
  for(pos = offset; pos < end; pos++) {
    printf(" %02X", bytes[pos]);
  }
}


void load_icon(gchar* img_type, gchar* img_path, guint* ndata, CARD32** data) {
  /* Note:
   *  Despite the fact this routine specifically loads 32bit data, it needs
   *  to load it into an unsigned long int array, not a guint32 array.
   *  The XChangeProperty() call wants to see a native size array when
   *  format == 32, not necessarily a 32bit one.
   */

  image_reader_fun_ptr reader = decide_image_reader(img_type, img_path);

  FILE* iconfile = fopen(img_path, "r");
  if (!iconfile) { failed("open file for reading:", img_path); }

  gdImagePtr icon = (*reader)(iconfile);
  fclose(iconfile);
  if (!icon) { failed("parse data from icon file", img_path); }

  int width = gdImageSX(icon);
  int height = gdImageSY(icon);
  if (verbose) {
    printf("D: Icon dimensions: %d x %d pixels.\n", width, height);
  }

  (*ndata) = (width * height) + 2;
  (*data) = g_new0(CARD32, (*ndata));
  uchar* bytes = (uchar*)(*data);

  int i = 0;
  (*data)[i++] = width;
  (*data)[i++] = height;

  if (verbose) {
    printf("D: width  bytes:");
    dump_hex(bytes, 0, 4);
    printf(" Ã— height bytes:");
    dump_hex(bytes, 4, 4);
    printf("\n");
  }

  int x, y;
  for(y = 0; y < height; y++) {
    for(x = 0; x < width; x++) {
      // data is RGBA
      // We'll do some horrible data-munging here
      guint8* cols = (guint8*)&((*data)[i++]);

      int pixcolour = gdImageGetPixel(icon, x, y);

      cols[0] = gdImageBlue(icon, pixcolour);
      cols[1] = gdImageGreen(icon, pixcolour);
      cols[2] = gdImageRed(icon, pixcolour);

      /* Alpha is more difficult */
      int alpha = 127 - gdImageAlpha(icon, pixcolour); // 0 to 127

      // Scale it up to 0 to 255; remembering that 2*127 should be max
      if (alpha == 127)
        alpha = 255;
      else
        alpha *= 2;

      cols[3] = alpha;
    }
  }

  gdImageDestroy(icon);
}


gboolean str2ulong(gchar* s, unsigned long* u) {
  if (sscanf(s, "0x%lx", u)) { return TRUE; }
  if (sscanf(s, "%ld", u)) { return TRUE; }
  return FALSE;
}


int main(int argc, char* argv[]) {
  if (argc < 3) { usage(1); }
  if (!strcmp(argv[1], "-h")) { usage(0); }
  if (!strcmp(argv[1], "--help")) { usage(0); }

  guint argindex = 1;
  if (!strcmp(argv[argindex], "--verbose")) {
    verbose = TRUE;
    argindex++;
  }

  unsigned long tmpLong = 0;
  if (!str2ulong(argv[argindex], &tmpLong)) { failed("parse window ID"); }
  Window window = tmpLong;
  if (window < 1) { failed("invalid window ID, must be positive"); }
  if (verbose) { printf("D: Using window ID 0x%08lx\n", window); }
  argindex++;

  gchar* imType = argv[argindex];
  argindex++;
  gchar* imPath = argv[argindex];
  if (verbose) { printf("Loading %s image from file %s\n", imType, imPath); }
  guint nelements;
  CARD32* icondata;
  load_icon(imType, imPath, &nelements, &icondata);

  Display* display = XOpenDisplay(NULL);
  XSynchronize(display, TRUE);
  if (!display) { failed("XOpenDisplay"); }
  Atom iconprop = XInternAtom(display, "_NET_WM_ICON", 0);
  if (!iconprop) { failed("find XInternAtom _NET_WM_ICON"); }

  int result = XChangeProperty(display, window, iconprop,
    XA_CARDINAL, // Atom type
    32, // int format
    PropModeReplace, // int mode
    (uchar*)icondata, // unsigned char *data,
    nelements);

  if(!result) { failed("XChangeProperty"); }
  if(!XFlush(display)) { failed("XFlush"); }
  XCloseDisplay(display);
  return 0;
}
